{"posts":[{"title":"关于webservice的理解","text":"背景本科的时候，专业内写网站，使用的完全是RestfulAPI，SpringBoot + RestController一把梭，所以我并没有接触过webservice这个概念。第一次遇到还是在项目里，一个满满年代感的项目与维护了十年的代码。 概念理清项目里的webservice，本质上也是RPC(Remote Procedure Call - 远程过程调用)，司空见惯的Client调用Server，跟平时调用API接口在定位上没什么区别。 最大的区别在于实施方法，webservice采用的是SOAP协议，并且会生成WSDL这个描述性文件。 WSDL(Web Services Description Language)就是用XML接口的描述性文件，里面的内容包括Server端的url、可调用的方法、方法需要的参数、方法返回的参数等。基本上可以看作一个全面的API doc。 SOAP(Simple Object Access Protocal - 简单对象访问协议)可以简单理解为Http + XML，扩展起来就是Http POST，将header中的一个属性Content-Type设置为text/XML，传输的文本就会被格式化为XML。SOAP封装的内容非常多，包括但不限于消息内容、发送对象、接收处理的的框架等。 UDDI(Universal Description, Discovery and Integration - 通用描述、发现与集成服务)是一种目录服务，通过它，企业可以使用它对 Web services 进行注册和搜索。目前大部分企业使用webservice并不是必须使用UDDI，因为用户通过WSDL知道了webservice的地址，可以直接通过WSDL调用webservice。 整个流程理顺下来就是，Server发布webservice，Client根据Server发布的webservice生成WSDL，发送符合要求的SOAP信息，成功调用Server。 利与弊与SOAP相比，JSON在传输层面轻量了太多。 举例返回调用结果为OK，在JSON下，只需要返回{&quot;result&quot;: &quot;OK&quot;}。 而在SOAP下，不得不返回大量的描述性文件。 12345678910&lt;?XML version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;SOAP:Envelope XMLns:xsi=&quot;Http://www.w3.org/2001/XMLSchema-instance&quot; XMLns:xsd=&quot;Http://www.w3.org/2001/XMLSchema&quot; XMLns:SOAP=&quot;Http://schemas.XMLSOAP.org/SOAP/envelope/&quot;&gt;&lt;SOAP:Body&gt;&lt;GetUserProfileTypesResponse XMLns=&quot;Http://zeeq.zune.net/&quot;&gt;&lt;GetUserProfileTypesResult&gt;&lt;userType&gt;unsignedByte&lt;/userType&gt;&lt;/GetUserProfileTypesResult&gt;&lt;/GetUserProfileTypesResponse&gt;&lt;/SOAP:Body&gt;&lt;/SOAP:Envelope&gt; 在JSON下，对结果描述不够准确。例如{&quot;price&quot;: 10000}这行代码，并没有指明10000是int、float又或是double，所以实际开发中不得不用{&quot;price&quot;: &quot;10000.00&quot;}这种字符串形式让前端自行解析。在XML中，所有的类型都有准确的描述，所以webservice在信息的传输上更精准。 尽管各有各的利弊，时代的推动下，webservice几乎只剩下保守的老项目还在坚守。简洁的webapi已经占据了当前的主流。","link":"/2022/12/06/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/%E5%85%B3%E4%BA%8Ewebservice%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"Windows下解除端口号被占用","text":"问题背景运行web项目的时候，忘记关闭上一个项目，然后直接运行下一个项目。上一个项目仍在运行中，端口号被占用。 解决方法直接在CMD中找到被占用端口号的进程id，结束进程运行。 window+R 输入cmd netstat -ano | findstr 端口号 taskkill /f /pid 进程id 截图","link":"/2021/05/19/%E6%89%8B%E9%A1%BA/Windows%E4%B8%8B%E8%A7%A3%E9%99%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8/"},{"title":"Windows搭建Gosu开发环境","text":"背景目前的项目基于Guidewire框架，使用的开发语言是Gosu。在个人机器上搭建Gosu的开发环境用于学习语法特性。 环境搭建前期准备 IntelliJ IDEA 2019.3.5 OS Gosu插件（最新版仅支持2019.3.5，之后的版本无法导入至IDEA） Gosu运行环境（gosu-1.14.16-full.zip） JDK1.8 + （Gosu依赖基于JDK1.8 +） 配置手顺校验JDK在命令行中执行java -version，查看JDK版本是否 &gt; 1.8。 下载Gosu运行环境并解压缩https://gosu-lang.github.io/downloads.html IDEA中导入OS Gosu插件（本地导入或在线下载） 创建工程创建一个普通的Java工程Create New Project 2019.3.5版本的默认JDK为1.11，编译Gosu会产生doc警告，所以更正为JDK8 Next Finish 创建完成 导入Gosu依赖File -&gt; Project Structure Libraries -&gt; Java 选择步骤2.2.2解压缩完的文件夹下的所有依赖 jar 包 OK 创建Gosu类src -&gt; 右键 -&gt; New -&gt; Gosu类 随便写一个类名 创建完成 编写Gosu代码Main 类完整代码如下（代码块采用swift，因为Markdown不支持gs） 123456class Main { static function main(args: String[]) { print(&quot;hello&quot;) }} 运行右键 -&gt; Run 运行结果 Gosu完整文档https://gosu-lang.github.io/docs.html","link":"/2022/12/05/%E6%89%8B%E9%A1%BA/Windows%E6%90%AD%E5%BB%BAGosu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"iOS配置Git同步Obsidian","text":"背景语雀收费之后，知识管理平台的选择又一次成为令我头痛的事。最初的印象笔记、之后的有道云、再然后的语雀。好用的工具层出不穷，但是一旦深入使用后迁移平台却是难上加难。所以我最终选择Obsidian这种全平台、本地、基于Markdown的数据管理工具。 由于使用的Mac+iPhone，所以iCloud与Obsidian搭配其实已经实现了跨平台的数据交互。但是既然已经跨平台了，且本身作为程序员，GIthub与Git才是我最信任的工具。借此也诞生了这篇文章，既如何利用Git，实现全平台版本管理与数据同步。 分析由于iOS端的文件管理与Obsidian的软件特性，Obsidian只能读取自己文件夹下的资料。 具体如图： 所以尽管iOS上有很多Git软件，但是如果不能打破文件管理这个层级的问题，Obsidian无法读取到git软件操作的文档仓库。毕竟这不是PC平台，Obsidian可以任意的打开被git管理的指定文件夹。 方案方案一 利用working copy将git仓库映射到Obsidian文件夹下具体操作：https://zhuanlan.zhihu.com/p/531516583 原理很简单，Obsidian既然只能读自己文件夹下的文件，那么利用working copy，将仓库share到Obsidian下的valut即可。 这个方法优点是操作简单，所有的git操作完全可以在working copy的GUI下完成。缺点也很明显，working copy买断价128元。 方案二 利用ish挂载Obsidian的valut，并生成git仓库ish是一个基于iOS的shell应用，在程序内可以调用linux命令操作iOS系统。核心操作如标题，将Obsidian的valut文件夹直接挂载到ish文件夹内，然后就可以肆意处理。ish本身是linux环境，自然可以安装git。 具体参照：https://zhuanlan.zhihu.com/p/565028534(不必完全参照知乎回答，有些步骤可以省略，只要考虑核心步骤即可。) 核心步骤： 下载 ish和Obsidian App 在 ish内，下载Git等软件 利用Linux下的mount命令挂载Obsidian下的文件夹 依托于Obsidian文件夹，git初始化（因为有.obsidian文件，无法直接clone），并关联远程仓库地址 正常pull / push即可（记得checkout选择分支） 这个方案最大的优点是免费，缺点是必须懂git和linux。因为所有的操作都是通过命令行实施，包括后续的文档内容更新。 体验截图PC端Git客户端 PC端Obsidian 移动端ish管理文档 移动端Obsidian","link":"/2022/12/01/%E6%89%8B%E9%A1%BA/iOS%E9%85%8D%E7%BD%AEGit%E5%90%8C%E6%AD%A5Obsidian/"},{"title":"知乎禁止转载资料剪辑方案.md","text":"前提知乎文章禁止转载。 测试文章地址https://www.zhihu.com/question/22613022/answer/1339783823 环境：Windows10，Firefox浏览器（其他浏览器应该也可以）。 解决方案1. 右键，检查元素对准要剪辑的文章，右键，检查元素。 会出现页面所处的元素。 2. 复制所需的元素选中&lt;span&gt;层级，右键，复制，整体HTML。 3. 新建一个HTML文件右键，新建文本文档，将txt后缀改成html。 将步骤3复制的内容粘贴进去，保存并退出。 4. 利用浏览器打开HTML文件 注意： 部分图片处理不到位，建议手动一个个处理。推荐将页面的文字复制到语雀/word等文字处理工具中。","link":"/2022/11/30/%E6%89%8B%E9%A1%BA/%E7%9F%A5%E4%B9%8E%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD%E8%B5%84%E6%96%99%E5%89%AA%E8%BE%91%E6%96%B9%E6%A1%88/"},{"title":"FileZilla下载失败","text":"问题描述FileZilla 不能下载，已经连接服务器， 但右键的下载显示灰色。 解决方案先在左侧要存放的路径点击进去 然后再点右边的文件点击下载。 截图","link":"/2021/03/18/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/FileZilla%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/"},{"title":"gitignore忽略.idea无效","text":"发生原因idea创建工程时已经将它存储进暂存区。 解决方法利用 git rm --cached 从索引中删除.idea文件。","link":"/2021/07/08/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/gitignore%E5%BF%BD%E7%95%A5-idea%E6%97%A0%E6%95%88/"},{"title":"java编程思想第四版_第四章练习十_吸血鬼数答案","text":"题目 说明网上找了找各种答案，感觉怪怪的。大多用了各种字符串转换，自带的sort排序之类的。 初入编程做这个题目的新人应该还不懂这些，刚刚学完基本的+-*/%，所以写了这篇希望能帮助到新人。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package example;/* * 输出结果： * 1395=15*93 * 1260=21*60 * 1827=21*87 * 2187=27*81 * 1530=30*51 * 1435=35*41 * 6880=80*86*/public class Example4_10 { public static void main(String[] args) { int[] array1 = new int[4]; int[] array2 = new int[4]; for (int i = 10; i &lt; 100; i++) { for (int j = i + 1; j &lt; 100; j++) { int resultNum = i * j; if (resultNum &lt; 1000) { continue; } // 取i的十位和个位 array1[0] = i/10; array1[1] = i%10; // 取j的十位和个位 array1[2] = j/10; array1[3] = j%10; // 取乘积的千位、百位、十位和个位 array2[0] = resultNum/1000; array2[1] = resultNum/100%10; array2[2] = resultNum/10%10; array2[3] = resultNum%10; if (checkZero(array2[2], array2[3]) &amp;&amp; sortAndCompareDif(array1) &amp;&amp; sortAndCompareDif(array2) &amp;&amp; arraysEquals(array1, array2)) { System.out.println(resultNum + &quot;=&quot; + i + &quot;*&quot; + j); } } } } /** * 判断乘积最后两位是否为零 * @param num1 乘积第三位 * @param num2 乘积第四位 * @return 都为零返回false，否则返回true */ private static boolean checkZero(int num1, int num2) { return num1 == 0 &amp;&amp; num2 == 0 ? false : true; } /** * 排序的同时，判断是否有出现次数大于三的数 * @param nums 数组传值 * @return 判断每个值唯一的结果 */ private static boolean sortAndCompareDif(int[] nums) { for (int i = 0; i &lt; nums.length - 1; i++) { int count = 0; int tmp =i; for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] &lt; nums[tmp] ) { tmp = j; } else if (i &lt; 2 &amp;&amp; nums[j] == nums[i]) { count += 1; } } if (count &lt; 2) { int tmpNum = nums[tmp]; nums[tmp] = nums[i]; nums[i] = tmpNum; } else { return false; } } return true; } /** * 比较两个数组是否相同 * @param nums1 数组1 * @param nums2 数组2 * @return 返回比对结果 */ private static boolean arraysEquals(int[] nums1, int[] nums2) { if (nums1.length != nums2.length) { return false; } for (int index = 0; index &lt; nums1.length; index ++) { if (nums1[index] != nums2[index]) { return false; } } return true; }}","link":"/2020/03/22/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0%E5%8D%81-%E5%90%B8%E8%A1%80%E9%AC%BC%E6%95%B0%E7%AD%94%E6%A1%88/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Gosu","slug":"Gosu","link":"/tags/Gosu/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Obsidian","slug":"Obsidian","link":"/tags/Obsidian/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"知乎","slug":"知乎","link":"/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"开发总结","slug":"开发总结","link":"/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"手顺","slug":"手顺","link":"/categories/%E6%89%8B%E9%A1%BA/"},{"name":"爬坑记录","slug":"爬坑记录","link":"/categories/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"编程入门","slug":"编程入门","link":"/categories/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"pages":[]}