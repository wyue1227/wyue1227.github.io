{"posts":[{"title":"Python操作ini文件","text":"前期说明项目结构123PythonINIDemo |-MysqlConfig.ini |-PythonINIDemo.py MysqlConfig.ini文件初始内容1234[prod]url = jdbc:mysql://localhost:3306/produsername = prod1password = prod11 Python操作查询123456789101112131415161718192021222324import configparserconfig = configparser.ConfigParser()config.read(&quot;MysqlConfig.ini&quot;, encoding=&quot;utf-8&quot;)# 获取所有的section节点print(config.sections()) # ['prod']# 获取指定section的所有keyprint(config.options(&quot;prod&quot;)) # ['url', 'username', 'password']# 根据section与option，获取指定值print(config.get(&quot;prod&quot;, &quot;url&quot;)) # jdbc:mysql://localhost:3306/prodprint(config.get(&quot;prod&quot;, &quot;username&quot;)) # prod1print(config.get(&quot;prod&quot;, &quot;password&quot;)) # prod11# 获取section下所有的option(key, value)print(config.items(&quot;prod&quot;)) # [('url', 'jdbc:mysql://localhost:3306/prod'), ('username', 'prod1'), ('password', 'prod11')]# 检查指定 section/option 是否存在print(config.has_section(&quot;prod&quot;)) # Trueprint(config.has_option(&quot;prod&quot;, &quot;url&quot;)) # Trueprint(config.has_section(&quot;dev&quot;)) # Falseprint(config.has_option(&quot;prod&quot;, &quot;token&quot;)) # False 增改代码1234567891011121314151617181920212223242526272829303132import configparserconfig = configparser.ConfigParser()config.read(&quot;MysqlConfig.ini&quot;, encoding=&quot;utf-8&quot;)dev_section = &quot;dev&quot;dev_option = [&quot;url&quot;, &quot;username&quot;, &quot;password&quot;]dev_url = &quot;jdbc:mysql://localhost:3306/dev1&quot;dev_username = &quot;dev1&quot;dev_password = &quot;dev11&quot;# 创建sectionif not config.has_section(dev_section): config.add_section(dev_section)# 创建optionif not config.has_option(dev_section, dev_option[0]): config.set(dev_section, dev_option[0], dev_url)# 创建optionif not config.has_option(dev_section, dev_option[1]): config.set(dev_section, dev_option[1], dev_username)# 创建optionif not config.has_option(dev_section, dev_option[2]): config.set(dev_section, dev_option[2], dev_password)# 修改option(option不存在则创建)config.set(dev_section, dev_option[2], &quot;update_dev&quot;)# 将变更写入文件config.write(open(&quot;MysqlConfig.ini&quot;, &quot;w&quot;)) 测试结果（MysqlConfig.ini文件）123456789[prod]url = jdbc:mysql://localhost:3306/produsername = prod1password = prod11[dev]url = jdbc:mysql://localhost:3306/dev1username = dev1password = update_dev 删除123456789101112131415161718import configparserconfig = configparser.ConfigParser()config.read(&quot;MysqlConfig.ini&quot;, encoding=&quot;utf-8&quot;)config.add_section(&quot;test&quot;)config.set(&quot;test&quot;, &quot;url&quot;, &quot;testUrl&quot;)config.set(&quot;test&quot;, &quot;username&quot;, &quot;testUserName&quot;)print(config.items(&quot;test&quot;)) # [('url', 'testUrl'), ('username', 'testUserName')]# 删除optionconfig.remove_option(&quot;test&quot;, &quot;url&quot;)print(config.items(&quot;test&quot;)) # [('username', 'testUserName')]# 删除sectionconfig.remove_section(&quot;test&quot;)print(config.has_section(&quot;test&quot;)) # False","link":"/2023/03/01/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/Python%E6%93%8D%E4%BD%9Cini%E6%96%87%E4%BB%B6/"},{"title":"python应用简单总结","text":"跨文件调方法123# FileA.pydef test(): print(&quot;testA&quot;) 123# FileB.pyimport FileAFileA.test() 跨文件调类12345# FileA.pyclass A { def test(self): print(&quot;testA&quot;)} 1234# FileB.pyfrom FileA import Aa = A()a.test() 随机掉用list内元素123import randomprint(random.choice([1, 2, 3]))# 输出1 2 3中随机一个 字符串模板化12345678from string import TemplatetemplateStr=&quot;hello, $name&quot;print(Template(templateStr).substitute(name=&quot;world&quot;))# hello, worlddata = &quot;hello, {name}&quot;print(data.format(name=&quot;world&quot;))# hello, world 根据字符串调用方法12345678# 利用方法名字符串调用方法class Test: def test(self, param: str): print(param) def main(): func = getattr(self, &quot;test&quot;) data = func() 常用文件处理123456789101112131415161718192021222324import osimport shutildef createFile(content: str, folderPath: str, fileName: str): # 路径不存在时创建文件夹 if not os.path.exists(folderPath): os.makedirs(folderPath) # 需要设置newline=&quot;\\n&quot;, encoding=&quot;utf-8&quot;时追加参数 writeContent(folderPath + fileName, content)def copyFile(fromPath: str, toPath: str): shutil.copy(fromPath, toPath)def getFileContent(filePath: str, newline=&quot;\\n&quot;, encoding=&quot;utf-8&quot;) -&gt; str: file = open(filePath,'r', encoding=encoding, newline=newline) data = file.read() file.close() return datadef writeContent(filePath: str, content: str, newline=&quot;\\n&quot;, encoding=&quot;utf-8&quot;): # newline控制换行符，Windows下设置为\\r\\n，Unix下设置为\\n file = open(filePath, &quot;w+&quot;, encoding=encoding, newline=newline) file.write(content) file.close() 生成随机日期123456789101112# 生成日期范围内的日期from datetime import datetime, timedeltadef random_date(startDate, endDate) -&gt; str: delta = endDate - startDate seconds = delta.total_seconds() n = random.randrange(seconds) return startDate + timedelta(seconds=n)startDate = datetime.strptime('1/1/2022', '%m/%d/%Y')endDate = datetime.strptime('12/31/2022', '%m/%d/%Y')print(str(random_date(startDate, endDate))) Excel数据转listExcel数据直接粘贴到编辑器中时，单元格数据之间有换行符\\t，可以借此拆分 123456789101112data = '''test1 test2 test3test11 test22 test33'''data = data.splitlines()data.remove('')result = []for tmp in data: tmpList = tmp.split(&quot;\\t&quot;) result.append(tmpList)print(result)# [['test1', 'test2', 'test3'], ['test11', 'test22', 'test33']]","link":"/2023/02/14/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/python%E5%BA%94%E7%94%A8%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"},{"title":"关于webservice的理解","text":"背景本科的时候，专业内写网站，使用的完全是RestfulAPI，SpringBoot + RestController一把梭，所以我并没有接触过webservice这个概念。第一次遇到还是在项目里，一个满满年代感的项目与维护了十年的代码。 概念理清项目里的webservice，本质上也是RPC(Remote Procedure Call - 远程过程调用)，司空见惯的Client调用Server，跟平时调用API接口在定位上没什么区别。 最大的区别在于实施方法，webservice采用的是SOAP协议，并且会生成WSDL这个描述性文件。 WSDL(Web Services Description Language)就是用XML接口的描述性文件，里面的内容包括Server端的url、可调用的方法、方法需要的参数、方法返回的参数等。基本上可以看作一个全面的API doc。 SOAP(Simple Object Access Protocal - 简单对象访问协议)可以简单理解为Http + XML，扩展起来就是Http POST，将header中的一个属性Content-Type设置为text/XML，传输的文本就会被格式化为XML。SOAP封装的内容非常多，包括但不限于消息内容、发送对象、接收处理的的框架等。 UDDI(Universal Description, Discovery and Integration - 通用描述、发现与集成服务)是一种目录服务，通过它，企业可以使用它对 Web services 进行注册和搜索。目前大部分企业使用webservice并不是必须使用UDDI，因为用户通过WSDL知道了webservice的地址，可以直接通过WSDL调用webservice。 整个流程理顺下来就是，Server发布webservice，Client根据Server发布的webservice生成WSDL，发送符合要求的SOAP信息，成功调用Server。 利与弊与SOAP相比，JSON在传输层面轻量了太多。 举例返回调用结果为OK，在JSON下，只需要返回{&quot;result&quot;: &quot;OK&quot;}。 而在SOAP下，不得不返回大量的描述性文件。 12345678910&lt;?XML version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;SOAP:Envelope XMLns:xsi=&quot;Http://www.w3.org/2001/XMLSchema-instance&quot; XMLns:xsd=&quot;Http://www.w3.org/2001/XMLSchema&quot; XMLns:SOAP=&quot;Http://schemas.XMLSOAP.org/SOAP/envelope/&quot;&gt;&lt;SOAP:Body&gt;&lt;GetUserProfileTypesResponse XMLns=&quot;Http://zeeq.zune.net/&quot;&gt;&lt;GetUserProfileTypesResult&gt;&lt;userType&gt;unsignedByte&lt;/userType&gt;&lt;/GetUserProfileTypesResult&gt;&lt;/GetUserProfileTypesResponse&gt;&lt;/SOAP:Body&gt;&lt;/SOAP:Envelope&gt; 在JSON下，对结果描述不够准确。例如{&quot;price&quot;: 10000}这行代码，并没有指明10000是int、float又或是double，所以实际开发中不得不用{&quot;price&quot;: &quot;10000.00&quot;}这种字符串形式让前端自行解析。在XML中，所有的类型都有准确的描述，所以webservice在信息的传输上更精准。 尽管各有各的利弊，时代的推动下，webservice几乎只剩下保守的老项目还在坚守。简洁的webapi已经占据了当前的主流。","link":"/2022/12/06/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/%E5%85%B3%E4%BA%8Ewebservice%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"字符串换行实际应用","text":"背景最近在 毎日のんびり日本語教師 网站上学习日语语法，其中的部分例句打算复制（摘抄）到Notion上作为笔记记录。但是奇怪的事情发生了 =&gt; 网站原文例句 粘贴到Notion之后 换行错乱了，很不开心。 =-= 解决问题思路利用Python脚本，调整字符串格式，给每段的换行前加上 “/n”。 代码1234567string = '''（１） 本当に好きな以上は仕方ない。 （如果真的喜欢那就没办法了。） （２） 給料を貰ってる以上は一生懸命やるのみ。 （既然领了工资，就只能拼命工作。）'''string = string.replace(&quot;（&quot;, &quot;\\n（&quot;) 此时，控制台输出的代码直接粘贴到Notion即可。 控制台 Notion 进阶方案从控制台里复制，然后再粘贴到Notion里，其实还是有点麻烦。所以找找方案，想办法解决掉复制这个费时间的操作。最终找到了 pyperclip 这个库。 改造一下代码，让运行结果直接复制到系统的剪贴板里。 123456789import pyperclipstring = '''（１） 本当に好きな以上は仕方ない。 （如果真的喜欢那就没办法了。） （２） 給料を貰ってる以上は一生懸命やるのみ。 （既然领了工资，就只能拼命工作。）'''string = string.replace(&quot;（&quot;, &quot;\\n（&quot;)pyperclip.copy(string) # 此时已经粘贴至粘贴板，直接粘贴即可。 后话其实仔细想想，打包一个GUI工具，包含文本框，change按钮，clear按钮，效率会更高。省的每次都要重新再代码里找位置粘贴。计划暂缓，有生之年吧。还是先过语言考试再说，奇淫技巧缓缓先=-=。","link":"/2022/12/29/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8D%A2%E8%A1%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"},{"title":"Windows下解除端口号被占用","text":"问题背景运行web项目的时候，忘记关闭上一个项目，然后直接运行下一个项目。上一个项目仍在运行中，端口号被占用。 解决方法直接在CMD中找到被占用端口号的进程id，结束进程运行。 window+R 输入cmd netstat -ano | findstr 端口号 taskkill /f /pid 进程id 截图","link":"/2021/05/19/%E6%89%8B%E9%A1%BA/Windows%E4%B8%8B%E8%A7%A3%E9%99%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%A2%AB%E5%8D%A0%E7%94%A8/"},{"title":"Windows搭建Gosu开发环境","text":"背景目前的项目基于Guidewire框架，使用的开发语言是Gosu。在个人机器上搭建Gosu的开发环境用于学习语法特性。 环境搭建前期准备 IntelliJ IDEA 2019.3.5 OS Gosu插件（最新版仅支持2019.3.5，之后的版本无法导入至IDEA） Gosu运行环境（gosu-1.14.16-full.zip） JDK1.8 + （Gosu依赖基于JDK1.8 +） 配置手顺校验JDK在命令行中执行java -version，查看JDK版本是否 &gt; 1.8。 下载Gosu运行环境并解压缩https://gosu-lang.github.io/downloads.html IDEA中导入OS Gosu插件（本地导入或在线下载） 创建工程创建一个普通的Java工程Create New Project 2019.3.5版本的默认JDK为1.11，编译Gosu会产生doc警告，所以更正为JDK8 Next Finish 创建完成 导入Gosu依赖File -&gt; Project Structure Libraries -&gt; Java 选择步骤2.2.2解压缩完的文件夹下的所有依赖 jar 包 OK 创建Gosu类src -&gt; 右键 -&gt; New -&gt; Gosu类 随便写一个类名 创建完成 编写Gosu代码Main 类完整代码如下（代码块采用swift，因为Markdown不支持gs） 123456class Main { static function main(args: String[]) { print(&quot;hello&quot;) }} 运行右键 -&gt; Run 运行结果 Gosu完整文档https://gosu-lang.github.io/docs.html","link":"/2022/12/05/%E6%89%8B%E9%A1%BA/Windows%E6%90%AD%E5%BB%BAGosu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"iOS配置Git同步Obsidian","text":"背景语雀收费之后，知识管理平台的选择又一次成为令我头痛的事。最初的印象笔记、之后的有道云、再然后的语雀。好用的工具层出不穷，但是一旦深入使用后迁移平台却是难上加难。所以我最终选择Obsidian这种全平台、本地、基于Markdown的数据管理工具。 由于使用的Mac+iPhone，所以iCloud与Obsidian搭配其实已经实现了跨平台的数据交互。但是既然已经跨平台了，且本身作为程序员，GIthub与Git才是我最信任的工具。借此也诞生了这篇文章，既如何利用Git，实现全平台版本管理与数据同步。 分析由于iOS端的文件管理与Obsidian的软件特性，Obsidian只能读取自己文件夹下的资料。 具体如图： 所以尽管iOS上有很多Git软件，但是如果不能打破文件管理这个层级的问题，Obsidian无法读取到git软件操作的文档仓库。毕竟这不是PC平台，Obsidian可以任意的打开被git管理的指定文件夹。 方案方案一 利用working copy将git仓库映射到Obsidian文件夹下具体操作：https://zhuanlan.zhihu.com/p/531516583 原理很简单，Obsidian既然只能读自己文件夹下的文件，那么利用working copy，将仓库share到Obsidian下的valut即可。 这个方法优点是操作简单，所有的git操作完全可以在working copy的GUI下完成。缺点也很明显，working copy买断价128元。 方案二 利用ish挂载Obsidian的valut，并生成git仓库ish是一个基于iOS的shell应用，在程序内可以调用linux命令操作iOS系统。核心操作如标题，将Obsidian的valut文件夹直接挂载到ish文件夹内，然后就可以肆意处理。ish本身是linux环境，自然可以安装git。 具体参照：https://zhuanlan.zhihu.com/p/565028534(不必完全参照知乎回答，有些步骤可以省略，只要考虑核心步骤即可。) 核心步骤： 下载 ish和Obsidian App 在 ish内，下载Git等软件 利用Linux下的mount命令挂载Obsidian下的文件夹 依托于Obsidian文件夹，git初始化（因为有.obsidian文件，无法直接clone），并关联远程仓库地址 正常pull / push即可（记得checkout选择分支） 这个方案最大的优点是免费，缺点是必须懂git和linux。因为所有的操作都是通过命令行实施，包括后续的文档内容更新。 体验截图PC端Git客户端 PC端Obsidian 移动端ish管理文档 移动端Obsidian","link":"/2022/12/01/%E6%89%8B%E9%A1%BA/iOS%E9%85%8D%E7%BD%AEGit%E5%90%8C%E6%AD%A5Obsidian/"},{"title":"newbee-mall-api部署手顺","text":"简介newbee-mall-api 是一个前后端分离商城系统的后端API接口。 项目地址https://gitee.com/newbee-ltd/newbee-mall-api 部署Clone代码 导入 SQL创建DBDB名：newbee_mall_db_v2（参照 application.properties -&gt; spring.datasource.url字段） 执行SQLSQL文件位置：newbee-mall-api\\src\\main\\resources\\newbee_mall_db_v2_schema.sql MySQL导入命令：source ※导入失败的解决方案 MySQL执行SQL脚本报错 ERROR 1231 (42000) 项目配置更改resources（newbee-mall-api\\src\\main\\resources）下关于DB的相关配置。 包括数据库地址、用户名、密码等。 利用mvn install打jar包 运行jar包 ※更多运行jar包形式参照 https://www.cnblogs.com/hxun/p/11325558.html 登录swagger查看接口","link":"/2023/01/10/%E6%89%8B%E9%A1%BA/newbee-mall-api%E9%83%A8%E7%BD%B2%E6%89%8B%E9%A1%BA/"},{"title":"博客搭建指南","text":"写在前面hexo本身是一个成熟的博客系统，所以简中互联网上关于搭建的帖子/博客铺天盖地。事实上hexo官网已经对应的插件官网即可解决大多数问题，其他平台（例如CSDN、掘金、Bilibili等）分享的帖子反而有可能有坑，所以尽可能围绕官网为主。 本地搭建 安装nodejs。nodejs官网：https://nodejs.org/zh-cn/ 安装hexo。hexo官网：https://hexo.io/zh-cn/ 关于hexo的使用说明及常用命令参考步骤2的官网即可。（大致操作如下） 其他配置 主题采用的icarus，说明文档也是用github page完成。最新的icarus主题支持npm install一键安装。 本地编辑器用的VSCode，为了方便使用，最好对工程加以改造。 source下新建images文件夹作为图片根路径（与_posts平级） 粘贴图片使用Paste Image插件，设置images文件夹为粘贴路径 评论系统使用的是utterances，利用issue实现评论与关联。具体参照https://utteranc.es 发布优化github page发布的是静态页面，hexo原生的hexo d虽然可以一键发布，但是并不适合文档的git管理。一旦换了电脑，工程同步很麻烦。 引入了github action之后，工作流演变成 hexo n新建文档 写完push到main分支 github action调用hexo d将静态资源发布到gh-pages分支上 github page动态更新 具体实施与yml可参照官网 补充说明如果不愿意像官网一般公开Markdown文档到github.io仓库，可以文档单独存放在另一个私有仓库，将生成的资源单独推送到github.io仓库。 推送权限依赖ssh密钥，需要将id_rsa文件作为变量存放到github中，但是一定要注意是包含开头和结尾的-----BEGIN RSA PRIVATE KEY-----与-----END RSA PRIVATE KEY-----。（踩坑许久） 12345-----BEGIN RSA PRIVATE KEY-----MIIJKAIBAAKCAgEAtgogG4V42h1XxZcaqHW1j6dG7UcOxNSSXOXNOFr0soTCyUqg....u+n08VOXbUSHb5udtFbNiF8si7JYG1ng/63r6wRsPjgc+5ePLatHhNGx+hw=-----END RSA PRIVATE KEY-----","link":"/2022/12/18/%E6%89%8B%E9%A1%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"},{"title":"知乎禁止转载资料剪辑方案.md","text":"前提知乎文章禁止转载。 测试文章地址https://www.zhihu.com/question/22613022/answer/1339783823 环境：Windows10，Firefox浏览器（其他浏览器应该也可以）。 解决方案1. 右键，检查元素对准要剪辑的文章，右键，检查元素。 会出现页面所处的元素。 2. 复制所需的元素选中&lt;span&gt;层级，右键，复制，整体HTML。 3. 新建一个HTML文件右键，新建文本文档，将txt后缀改成html。 将步骤3复制的内容粘贴进去，保存并退出。 4. 利用浏览器打开HTML文件 注意： 部分图片处理不到位，建议手动一个个处理。推荐将页面的文字复制到语雀/word等文字处理工具中。","link":"/2022/11/30/%E6%89%8B%E9%A1%BA/%E7%9F%A5%E4%B9%8E%E7%A6%81%E6%AD%A2%E8%BD%AC%E8%BD%BD%E8%B5%84%E6%96%99%E5%89%AA%E8%BE%91%E6%96%B9%E6%A1%88/"},{"title":"Moji每日练习","text":"295職場の環境に満足していたので、その当時は転職など全く（ ）になかった。 念頭 本心 念願 内心 昨今、森林を単に木材の供給源 ____ ★ ____ ____ と捉えることの重要性が広く認識されてきている。 のみではなく 環境資源 として 水や空気を育む 296この書類に必要なことを記入して窓口に提出すれば、手続きは（ ）します。 完了 決定 実現 達成 「来週の登山の持ち物について質問があります。配られたプリントに、ビニール袋を持参 ____ ____ ★ ____ 足りるのでしょうか。」 ありますが だいたい何枚ぐらい のことと 用意すれば 297弊社の採用試験では、筆記試験よりも面接に（ ）を置いています。 ウエイト トップ パワー メイン 工面 制度の改正を求めて、街頭で署名を工面する活動を続けた。 サービス向上のために、利用者からアイディアを工面した。 選挙が近くになり、各政党は候補者を工面するのに必死だ。 なんとか資金を工面して、ついに自分の店を持つことができた。","link":"/2023/01/27/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/Moji%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0/"},{"title":"Eclipse中，中文变成繁体字","text":"问题描述：在Eclipse中打字，突然注释代码只能打出来繁体字。 截图： 问题出现的原因Eclipse中，格式化代码 Ctrl + Shift + F，同时是搜狗的简繁体转换快捷键。 解决方案再按一次格式化代码（Ctrl + Shift + F），然后去搜狗里将简繁体转换快捷键更换。 关闭搜狗简繁体转换方案1. 右键输入法 -&gt; 属性设置 2. 高级 -&gt; 系统功能快捷键 3. 关闭简繁切换 关联问题Eclipse格式化代码失效","link":"/2023/02/05/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/Eclipse%E4%B8%AD%E6%96%87%E5%8F%98%E6%88%90%E7%B9%81%E4%BD%93%E5%AD%97/"},{"title":"Eclipse格式化代码失效","text":"原因Ctrl + shift + F 跟Windows原生输入法的简繁体转换冲突，需要关闭输入法的简繁体转换。 截图 关联问题Eclipse中，中文变成繁体字","link":"/2023/02/05/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/Eclipse%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%A4%B1%E6%95%88/"},{"title":"FileZilla下载失败","text":"问题描述FileZilla 不能下载，已经连接服务器， 但右键的下载显示灰色。 解决方案先在左侧要存放的路径点击进去 然后再点右边的文件点击下载。 截图","link":"/2021/03/18/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/FileZilla%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/"},{"title":"MySQL执行SQL脚本报错 ERROR 1231 (42000)","text":"错误场景登录MySQL，利用source命令导入sql文件时报错。 错误截图 解决方法在sql文件前加入下面注释： 12345678910/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE='+00:00' */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; 示例","link":"/2023/01/10/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/MySQL%E6%89%A7%E8%A1%8CSQL%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%991231(42000)/"},{"title":"Python报错UnicodeDecodeError","text":"背景Python IO读取文件时报错UnicodeDecodeError: ‘gbk’ codec can’t decode byte... 错误原因如同报错信息，Unicode解码失败。根本原因是文件中有汉字/日文等其他文字不能用gbk打开。 解决方法利用utf-8格式打开 1file = open(filename, encoding=&quot;utf8&quot;)","link":"/2023/02/14/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/Python%E6%8A%A5%E9%94%99UnicodeDecodeError/"},{"title":"gitignore忽略.idea无效","text":"发生原因idea创建工程时已经将它存储进暂存区。 解决方法利用 git rm --cached 从索引中删除.idea文件。","link":"/2021/07/08/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/gitignore%E5%BF%BD%E7%95%A5-idea%E6%97%A0%E6%95%88/"},{"title":"git stash误删除后找回","text":"背景stash list在脑子不清醒的时候误删除了，要找回内容。 解决步骤1 git fsck –lost-found（列出删除的commit） 2 git show + &lt;sha&gt;逐个commit查看，直到找到误删的commit。 3 git merge + &lt;sha&gt;找回误删除的代码。 4 git reset如果不打算提交，还原索引至上一版本。","link":"/2023/02/05/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/GitStash%E8%AF%AF%E5%88%A0%E9%99%A4%E5%90%8E%E6%89%BE%E5%9B%9E/"},{"title":"java编程思想第四版_第四章练习十_吸血鬼数答案","text":"题目 说明网上找了找各种答案，感觉怪怪的。大多用了各种字符串转换，自带的sort排序之类的。 初入编程做这个题目的新人应该还不懂这些，刚刚学完基本的+-*/%，所以写了这篇希望能帮助到新人。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package example;/* * 输出结果： * 1395=15*93 * 1260=21*60 * 1827=21*87 * 2187=27*81 * 1530=30*51 * 1435=35*41 * 6880=80*86*/public class Example4_10 { public static void main(String[] args) { int[] array1 = new int[4]; int[] array2 = new int[4]; for (int i = 10; i &lt; 100; i++) { for (int j = i + 1; j &lt; 100; j++) { int resultNum = i * j; if (resultNum &lt; 1000) { continue; } // 取i的十位和个位 array1[0] = i/10; array1[1] = i%10; // 取j的十位和个位 array1[2] = j/10; array1[3] = j%10; // 取乘积的千位、百位、十位和个位 array2[0] = resultNum/1000; array2[1] = resultNum/100%10; array2[2] = resultNum/10%10; array2[3] = resultNum%10; if (checkZero(array2[2], array2[3]) &amp;&amp; sortAndCompareDif(array1) &amp;&amp; sortAndCompareDif(array2) &amp;&amp; arraysEquals(array1, array2)) { System.out.println(resultNum + &quot;=&quot; + i + &quot;*&quot; + j); } } } } /** * 判断乘积最后两位是否为零 * @param num1 乘积第三位 * @param num2 乘积第四位 * @return 都为零返回false，否则返回true */ private static boolean checkZero(int num1, int num2) { return num1 == 0 &amp;&amp; num2 == 0 ? false : true; } /** * 排序的同时，判断是否有出现次数大于三的数 * @param nums 数组传值 * @return 判断每个值唯一的结果 */ private static boolean sortAndCompareDif(int[] nums) { for (int i = 0; i &lt; nums.length - 1; i++) { int count = 0; int tmp =i; for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] &lt; nums[tmp] ) { tmp = j; } else if (i &lt; 2 &amp;&amp; nums[j] == nums[i]) { count += 1; } } if (count &lt; 2) { int tmpNum = nums[tmp]; nums[tmp] = nums[i]; nums[i] = tmpNum; } else { return false; } } return true; } /** * 比较两个数组是否相同 * @param nums1 数组1 * @param nums2 数组2 * @return 返回比对结果 */ private static boolean arraysEquals(int[] nums1, int[] nums2) { if (nums1.length != nums2.length) { return false; } for (int index = 0; index &lt; nums1.length; index ++) { if (nums1[index] != nums2[index]) { return false; } } return true; }}","link":"/2020/03/22/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%83%E4%B9%A0%E5%8D%81-%E5%90%B8%E8%A1%80%E9%AC%BC%E6%95%B0%E7%AD%94%E6%A1%88/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"代码段","slug":"代码段","link":"/tags/%E4%BB%A3%E7%A0%81%E6%AE%B5/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Gosu","slug":"Gosu","link":"/tags/Gosu/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Obsidian","slug":"Obsidian","link":"/tags/Obsidian/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"知乎","slug":"知乎","link":"/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"Moji","slug":"Moji","link":"/tags/Moji/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"}],"categories":[{"name":"开发总结","slug":"开发总结","link":"/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"手顺","slug":"手顺","link":"/categories/%E6%89%8B%E9%A1%BA/"},{"name":"日语学习","slug":"日语学习","link":"/categories/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"爬坑记录","slug":"爬坑记录","link":"/categories/%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"编程入门","slug":"编程入门","link":"/categories/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}],"pages":[]}